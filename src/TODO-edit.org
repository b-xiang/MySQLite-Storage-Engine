* Features to add
  - ずっと自分定義のconnectionを保持して，結局file descriptorを保持し続けているのがいけない．
    rnd_init()の度に少なくとも fopen() しなおさないと，SQLite からinsertされたことを検知できない．
  - MySQLiteでSQLite DBを見ているときに，別のSQLiteプロセスにスキーマを変更されると，いけないことになる．
    MySQLiteが，あるテーブルに対するクエリを検知する度に，SQLite DBの中身を再確認し，今自分が知っている
    スキーマとSQLite DBの中のスキーマが対応しているかを確認する．
    対応していなかったら，MySQLiteの側でエラーを出すというのが第一歩，
    発展的には，エラーを出しつつSQLite DBのスキーマに追従したい．
  - Support index scan. See http://dev.mysql.com/doc/internals/en/support-for-indexing.html
    And see get_cellpos_by_key_aux() which has been removed at commit 39c70d751
    - See ha_myisam::index_read_map(), especially how *key parameter is treated.
      *key has all information on search range.
  - INTEGER PRIMARY KEY support. See http://www.sqlite.org/lang_createtable.html#rowid
  - Buffer pool for internal data management like copying rows to buffer.
  - *Shared page cache* with all connections.
    Single mysqld process treats all connections,
    so it can defeat original SQLite with many connections.
  - Locks between mysql client (= mysqld threads).
    ha_tina.cc seems to implement table lock.  But not sure whether it has reader/writer lock...
    First, ignore any locks!!
  - Locks between sqlite3 processes = Database locks (closely related to page cache).
    - shared lock, reserved lock, pending lock, and exclusive lock.
      See
      - "The Definitive Guide to SQLite - Database Locks"
      - http://www.sqlite.org/lockingv3.html
      - notebook
  - Table lock for maintaining cursor. See The Definitive Guide to SQLite - Table Locks"
  - Support all result value types. See http://www.sqlite.org/c3ref/column_blob.html
  - More sophisticated memory allocation. See http://www.sqlite.org/malloc.html
  - NULL column support (in find_current_row()).
  - MySQL cannot create column named 'sql', although I do not know why...
    Check MySQL limitation on such names.

* Fix
  - Log errors in APIs
  - Reconsider when to read DB header. Everytime? Idiot.
  - MySQL does not support quoted ("", '') table name when CREATE TABLE, while SQLite does.
